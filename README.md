## Инструкция по запуску проекта

Требования: Docker и docker-compose.

Из корня репозитория:
```
docker compose up --build -d
```

Сервисы: API — порт 8000, PostgreSQL — 5432, RabbitMQ — 5672 и 15672 (management). Документация API: http://localhost:8000/docs. Создание задачи: `POST http://localhost:8000/tasks` с телом `{"payload": "str"}`; в ответ приходит `task_id`. Остановка: `docker compose down`.

## Архитектурные решения

Сервис построен как API + фоновый воркер: API принимает задачи, сохраняет их в PostgreSQL и публикует идентификатор в очередь RabbitMQ; воркер забирает сообщения из очереди, обрабатывает задачу (имитация 2–5 с) и обновляет статус и результат в БД. Очередь — RabbitMQ (обоснование в п. 1). Доступ к БД вынесен в слой репозиториев, оркестрация — в сервисах; API только вызывает сервисы и возвращает ответы.

## 1. Почему вы выбрали RabbitMQ или Kafka

Выбран RabbitMQ: простая модель очереди (publish/consume + ack), один брокер с management UI, быстрый старт в Docker. Гарантий доставки и at-least-once хватает; идемпотентность — проверкой статуса в БД. Kafka избыточен для объёма и требований ТЗ.

## 2. Как бы вы масштабировали это решение

- Воркеры — горизонтально: несколько реплик `worker`, RabbitMQ распределяет сообщения между consumer'ами (prefetch + конкуренция за очередь).
- API — несколько реплик за балансировщиком (nginx/ingress); состояние только в БД и очереди.
- PostgreSQL — пул соединений в пределах лимитов; при росте нагрузки — read replicas для чтения, мастер для записи.
- RabbitMQ — при необходимости кластер (несколько нод) или mirrored queues для доступности; для старта хватает одного брокера.

## 3. Какие потенциальные точки отказа есть в текущей архитектуре

- PostgreSQL — один инстанс: падение или недоступность обрубает и API, и воркер; нет реплики для отказоустойчивости.
- RabbitMQ — один брокер: при падении новые задачи не публикуются, воркер не получает сообщения; необработанные сообщения в очереди сохраняются (durable), но приложение простаивает.
- Один контейнер api и один worker: выход одного из них снижает или останавливает обслуживание; нет резерва.
- Нет балансировщика перед API: при единственной реплике отказ api = полная недоступность сервиса.
- Сеть и хост: общий отказ хоста или сети между сервисами ломает всю цепочку (api → postgres/rabbitmq, worker → postgres/rabbitmq).

## 4. Что бы вы улучшили, если бы это был продакшен

- Авторизация и разграничение доступа (API keys, JWT или OAuth).
- Структурированное логирование (JSON, уровни, request_id) и централизованный сбор логов.
- Тесты: unit для сервисов и репозиториев, интеграционные для API и воркера.
- Миграции БД через Alembic вместо create_all при старте; версионирование схемы.
- Секреты и конфиг из внешнего хранилища (Vault, env в оркестраторе), не дефолтные пароли.
- Rate limiting и лимиты на размер payload на API.
- Graceful shutdown воркера (дообработка очереди перед выходом), healthcheck для api и worker.
- Метрики (Prometheus) и трейсинг запросов; опционально feature flags.
