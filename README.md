## 1. Почему вы выбрали RabbitMQ или Kafka

Выбран RabbitMQ: простая модель очереди (publish/consume + ack), один брокер с management UI, быстрый старт в Docker. Гарантий доставки и at-least-once хватает; идемпотентность — проверкой статуса в БД. Kafka избыточен для объёма и требований ТЗ.

## 2. Как бы вы масштабировали это решение

- Воркеры — горизонтально: несколько реплик `worker`, RabbitMQ распределяет сообщения между consumer'ами (prefetch + конкуренция за очередь).
- API — несколько реплик за балансировщиком (nginx/ingress); состояние только в БД и очереди.
- PostgreSQL — пул соединений в пределах лимитов; при росте нагрузки — read replicas для чтения, мастер для записи.
- RabbitMQ — при необходимости кластер (несколько нод) или mirrored queues для доступности; для старта хватает одного брокера.

## 3. Какие потенциальные точки отказа есть в текущей архитектуре

- PostgreSQL — один инстанс: падение или недоступность обрубает и API, и воркер; нет реплики для отказоустойчивости.
- RabbitMQ — один брокер: при падении новые задачи не публикуются, воркер не получает сообщения; необработанные сообщения в очереди сохраняются (durable), но приложение простаивает.
- Один контейнер api и один worker: выход одного из них снижает или останавливает обслуживание; нет резерва.
- Нет балансировщика перед API: при единственной реплике отказ api = полная недоступность сервиса.
- Сеть и хост: общий отказ хоста или сети между сервисами ломает всю цепочку (api → postgres/rabbitmq, worker → postgres/rabbitmq).

## 4. Что бы вы улучшили, если бы это был продакшен

- Авторизация и разграничение доступа (API keys, JWT или OAuth).
- Структурированное логирование (JSON, уровни, request_id) и централизованный сбор логов.
- Тесты: unit для сервисов и репозиториев, интеграционные для API и воркера.
- Миграции БД через Alembic вместо create_all при старте; версионирование схемы.
- Секреты и конфиг из внешнего хранилища (Vault, env в оркестраторе), не дефолтные пароли.
- Rate limiting и лимиты на размер payload на API.
- GET /tasks/{task_id} для проверки статуса и результата задачи.
- Graceful shutdown воркера (дообработка очереди перед выходом), healthcheck для api и worker.
- Метрики (Prometheus) и трейсинг запросов; опционально feature flags.
